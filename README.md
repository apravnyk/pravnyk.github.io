## Readme Документація для Junior Розробника

### Загальні Питання:

1. **HTTP-запити:**
   - Так, я знайомий з основними методами HTTP-запитів, такими як GET, POST, PUT, DELETE, іншими.

2. **HTTP-протокол:**
   - Знаю різницю між HTTP/1.1 і HTTP/2. HTTP/2 використовує мультиплексування, що поліпшує продуктивність.

3. **HTTP коди відповіді:**
   - Розумію значення основних HTTP статус-кодів, таких як 200 OK, 404 Not Found, 500 Internal Server Error тощо.

4. **CORS:**
   - Cross-Origin Resource Sharing (CORS) дозволяє чи обмежує запити до ресурсів на іншому домені. Проблеми з CORS можна вирішити, налаштовуючи заголовки на сервері, наприклад, додавши `Access-Control-Allow-Origin`.

5. **Cookies:**
   - Cookies - це дані, які зберігаються в браузері і відправляються з кожним запитом. Максимальний розмір cookies обмежений браузером і зазвичай складає 4 КБ на домен.

6. **Use Strict:**
   - Директива `"use strict";` вказує браузеру або движку JavaScript використовувати строгий режим, що поліпшує безпеку і виконання коду.

7. **JS на front-end та back-end:**
   - JS на front-end виконується в браузері і відповідає за взаємодію з користувачем. JS на back-end (за допомогою Node.js, наприклад) використовується для роботи на сервері.

8. **Типізація:**
   - Статична типізація передбачає визначення типів змінних під час компіляції (наприклад, TypeScript). Динамічна типізація дозволяє змінювати типи змінних під час виконання програми (наприклад, у JavaScript).

9. **Взаємодія клієнта з сервером:**
   - Клієнт і сервер взаємодіють за допомогою HTTP-запитів. Клієнт (браузер) робить запити, сервер обробляє їх і повертає відповіді.

10. **REST:**
    - REST (Representational State Transfer) - це архітектурний стиль для побудови веб-сервісів. Він використовує стандартні HTTP-методи і формати даних, такі як JSON.

11. **Мутабельність / Іммутабельність:**
    - Мутабельні об'єкти можна змінювати після створення, тоді як іммутабельні залишаються незмінними. Іммутабельні структури дозволяють покращити стійкість коду та спростити його аналіз.

12. **Пошук помилок:**
    - Для пошуку помилок використовую дебагер браузера, консольні виведення, а також інструменти розробника.

13. **JS Екосистема:**
    - Ознайомлений з відомими особами у світі JS, такими як Brendan Eich, Douglas Crockford, Addy Osmani тощо.


### JS Core:

14. **Типи даних:**
   - Основні типи даних у JS включають числа, рядки, булеві значення, об'єкти, масиви, null та undefined.

15. **Перевірка масиву:**
   - Для перевірки, чи об'єкт є масивом, можна використовувати метод Array.isArray() або оператор instanceof.

16. **Порівняння чисел:**
   - Для перевірки, чи число є скінченним, можна використовувати метод isFinite(). Порівняння з NaN можна здійснити за допомогою isNaN(). 

17. **isNaN() vs Number.isNaN():**
   - isNaN() перевіряє, чи передане значення є NaN, тоді як Number.isNaN() тільки тоді повертає true, якщо передане значення є строго NaN.

18. **Ключові слова var, let, const:**
   - `var` має функціональну область видимості, `let` та `const` - блочну. `let` дозволяє змінювати значення, `const` - ні.

19. **Область видимості:**
   - Область видимості визначає доступність змінних. Змінні, оголошені в блоку коду, можуть бути видимими тільки в цьому блоку.

20. **Деструктуризація:**
   - Деструктуризація дозволяє розпаковувати значення з об'єктів або масивів в окремі змінні.

21. **setTimeout і setInterval:**
   - `setTimeout` використовується для виконання функції після певного часового інтервалу. `setInterval` запускає функцію через певний інтервал часу.

22. **Асинхронний код:**
   - Порівняння підходів: callbacks, promises, async/await для обробки асинхронних операцій у JS.

23. **Розширення прототипів:**
   - Не рекомендується розширювати прототипи вбудованих об'єктів, таких як Array чи Object. Це може призвести до непередбачуваного поведінки.

24. **Методи масивів:**
   - Використовую основні методи масивів, такі як `map`, `filter`, `reduce`, для обробки та трансформації даних в масивах.

25. **Map і Set:**
   - `Map` - це колекція ключ-значення, а `Set` - множина унікальних значень. Вони дозволяють ефективно працювати з колекціями.

26. **Глибока та поверхнева копія:**
   - Глибока копія створює новий об'єкт зі скопійованими значеннями, в той час як поверхнева копія створює новий об'єкт, який посилається на ті ж самі об'єкти, що і оригінал.


### Функції:

27. **Декларація vs Функціональний вираз:** Відмінності між ними.
28. **Анонімна функція:** Опис концепції.
29. **Стрілкові функції:** Розуміння особливостей порівняно з іншими функціями.
30. **IIFE:** Використання та призначення.
31. **Hoisting:** Розуміння підняття змінних та функцій.
32. **Замикання (Closure):** Розуміння концепції та використання в коді.
33. **Рекурсія:** Опис використання рекурсії в коді.
34. **Ключове слово this:** Розуміння та використання в різних сценаріях.
35. **Втрата контексту:** Запобігання втраті контексту.
36. **Методи bind / call / apply:** Застосування та відмінності між ними.

### Front-end:

37. **DOM:** Знання та використання Document Object Model.
38. **Атрибути async і defer:** Порівняння та використання в HTML.
39. **innerHTML vs innerText:** Різниця між ними.
40. **Спливання подій (Bubbling):** Розуміння та використання в DOM.
41. **Зупинка спливання та дефолтної обробки:** Використання методів для контролю подій.
42. **this в обробнику подій:** Значення this в контексті обробника подій.
43. **LocalStorage та SessionStorage:** Знання та обмеження.
44. **Отримання висоти блоку:** Використання для отримання розмірів елемента.
45. **Webpack:** Знання концепції та відмінностей між dev- та prod-збіркою.

### Верстка:

53. **Блокова модель CSS:** Опис основних принципів блокової моделі CSS.

54. **Центрування блокового контенту:**
    - Горизонтально: Використання `margin: auto;` або `text-align: center;`.
    - Вертикально: Використання flexbox або grid.

55. **Підходи у верстці:**
    - Float, Flexbox, Grid та інші.

56. **Responsive Design:** Застосування медіа-запитів, використання відносиних одиниць вимірювання, flexbox, grid.

57. **Принципи семантичної верстки:** Використання тегів, які відповідають їх семантиці (наприклад, використання `nav`, `header`, `article`).

58. **Префікси для CSS-властивостей:** Використання префіксів для вирішення проблем кросбраузерності, коли браузери вимагають різні префікси для певних CSS властивостей.

59. **Кросбраузерні стилі:** Використання універсальних селекторів, розуміння відмінностей у підтримці властивостей.

60. **Практичне завдання:** Приведено приклад поганого CSS або HTML для коментування та виправлення.

61. **CSS-препроцесори:** Розуміння концепції та робота із препроцесорами (наприклад, Sass, Less). Опис переваг та нововведень, які вони вносять у стандартний CSS.

### React:

#### Класові компоненти:
1. **Чи працювали з класовими компонентами? Які їхні особливості?**
   - Так, працював з класовими компонентами. Основна особливість - використання класів ES6 для визначення компонентів, наявність методів життєвого циклу.

#### Збереження даних в стані та передача пропсів:
2. **Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.**
   - Дані, які змінюються та впливають на відображення компонента, зазвичай зберігаються в стані. Дані, які залишаються незмінними або передаються від батьківського компонента, можна передавати через пропси.

#### Хуки:
3. **Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?**
   - Так, ознайомлений. Хуки - це функції, які дозволяють використовувати стан та інші функціональності React в функціональних компонентах. Вони забезпечують кращий підхід до роботи зі станом та ефективніше використання логіки.

#### Фрагменти та портали:
4. **Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?**
   - Так, ознайомлений. Фрагменти використовуються для групування декількох елементів без створення зайвих вузлів в DOM. Портали дозволяють виводити дочірні елементи за межі батьківського DOM елемента.

#### Робота з методами життєвого циклу компонента:
5. **Які ви знаєте методи життєвого циклу компонента?**
   - `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` та інші.

6. **В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?**
   - `componentDidMount`. Викликається після того, як компонент вперше рендериться, ідеальний для запитів на сервер.

7. **В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?**
   - `componentDidMount` та `componentWillUnmount`. Підписка в `componentDidMount`, а відписка в `componentWillUnmount`, щоб уникнути витоку пам'яті.

8. **Чи був досвід роботи з контекстом? Коли його варто використовувати?**
   - Так, працював з контекстом. Використовується для передачі даних через дерево компонентів, коли важко передавати пропси через багато рівнів.

#### Інші питання:
9. **У чому особливість PureComponent?**
   - `PureComponent` автоматично реалізує метод `shouldComponentUpdate`, порівнюючи попередні та нові властивості та стани, і перерендерює компонент, якщо вони відрізняються.

10. **Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?**
    - Так, працював. Мемоізовані селектори зберігають результати попередніх обчислень, щоб уникнути повторних обчислень, коли вхідні дані не змінилися.

11. **У чому бачите переваги бібліотеки React?**
    - Легка вивчається, має велику та активну спільноту, прекрасно підходить для розробки великих та масштабованих додатків.

12. **Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?**
    - React швидка завдяки використанню Virtual DOM, що дозволяє мінімізувати операції зміни DOM. Shadow DOM дозволяє ізолювати стилі та DOM елементи компонента.

13. **Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?**
    - Ключі в списках допомагають React визначити, які елементи були додані, видалені чи змінились. Використання індексів можливе, але не рекомендується, оскільки це може призвести до проблем при оновленні.

14. **В чому основна ідея Redux?**
    - Redux - це бібліотека для управління станом додатку в одному зберігу. Головна ідея - утримання всього стану додатку в одному об'єкті (store), який не може бути змінений напряму.

15. **Робота зі стилями в React.**
    - Стилі можна використовувати як об'єкти в пропсі `style` або за допомогою CSS-in-JS бібліотек, таких як Styled Components.

16. **React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.**
    - React - це бібліотека для створення інтерфейсів користувача. Основна різниця в тому, що фреймворк надає готовий скелет та інструменти для розробки, в той час як бібліотека фокусується на конкретному завданні (наприклад, UI компоненти).

17. **Чи можна використовувати jQuery разом з React? Чому так / ні?**
    - Так, можна, але це не рекомендується. Використання jQuery разом з React може призвести до конфліктів, оскільки обидві бібліотеки можуть намагатися керувати DOM.

18. **Що таке codemod?**
    - Codemod - це інструмент для автоматизованої зміни вихідного коду програми. Використовується для впровадження масштабних змін в коді.

19. **Чи доводилося налаштовувати про

